use candid::CandidType;
use serde::{Deserialize, Serialize};

use super::BookingId;

#[derive(CandidType, Deserialize, Serialize, Clone, Debug, Default)]
pub struct PaymentDetails {
    // in frontend, we call this AppReference (because Provab calls it so.),
    // crux is -- this is generated by us and is unique for each booking
    pub booking_id: BookingId,

    /// this is the payment status that backend holds
    /// it is derived from payment_api_response.payment_status
    /// Why? - Many API providers will give different payment_status
    /// so, we want to have one invariant in backend
    pub payment_status: BackendPaymentStatus,
    /// this is the payment response from the payment provider
    pub payment_api_response: BEPaymentApiResponse,
}

#[derive(CandidType, Deserialize, Serialize, Debug, Clone, Default)]
pub struct BEPaymentApiResponse {
    pub provider: String,
    // Legacy field for backward compatibility
    #[serde(default)]
    #[deprecated(note = "Use payment_id_v2 instead")]
    pub payment_id: u64,
    // Primary payment_id field (String format)
    pub payment_id_v2: String,
    pub invoice_id: u64,
    pub payment_status: String,
    // pub pay_address: String,
    // pub payin_extra_id: Option<String>,
    pub price_amount: u64,
    pub price_currency: String,
    pub pay_amount: f64,
    pub actually_paid: f64,
    pub pay_currency: String,
    pub order_id: String,
    pub order_description: String,
    pub purchase_id: u64,
    // pub outcome_amount: f64,
    // pub outcome_currency: String,
    // pub payout_hash: Option<String>,
    // pub payin_hash: Option<String>,
    pub created_at: String,
    pub updated_at: String,
    // pub burning_percent: Option<String>,
    // #[serde(rename = "type")]
    // pub type_field: String,
}

impl PaymentDetails {
    pub fn new(booking_id: BookingId) -> Self {
        Self {
            booking_id,
            payment_status: BackendPaymentStatus::Unpaid(None),
            payment_api_response: BEPaymentApiResponse::default(),
        }
    }

    pub fn mark_payment_complete(&mut self, transaction_ref: String) -> Result<(), String> {
        self.payment_status = BackendPaymentStatus::Paid(transaction_ref);
        Ok(())
    }

    pub fn mark_payment_not_complete(&mut self, reason: String) {
        self.payment_status = BackendPaymentStatus::Unpaid(Some(reason));
    }

    pub fn get_status_display(&self) -> String {
        match &self.payment_status {
            BackendPaymentStatus::Paid(ref_no) => format!("Payment confirmed (Ref: {})", ref_no),
            BackendPaymentStatus::Unpaid(None) => "Awaiting payment".to_string(),
            BackendPaymentStatus::Unpaid(Some(error)) => format!("Payment failed: {}", error),
        }
    }

    pub fn is_paid(&self) -> bool {
        matches!(self.payment_status, BackendPaymentStatus::Paid(_))
    }
}

#[derive(CandidType, Deserialize, Serialize, Clone, Debug)]
pub enum BackendPaymentStatus {
    /// transaction reference number from payments provider
    Paid(String),
    /// if the transaction failed, that would be here.
    /// if transaction is processing, then that is here too.
    Unpaid(Option<String>),
}

impl Default for BackendPaymentStatus {
    fn default() -> Self {
        Self::Unpaid(None)
    }
}
