use candid::{CandidType, Principal};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

use super::BookingId;

#[derive(CandidType, Deserialize, Serialize, Clone, Debug, Default)]
pub struct PaymentDetails {
    // in frontend, we call this AppReference (because Provab calls it so.),
    // crux is -- this is generated by us and is unique for each booking
    pub booking_id: BookingId,
    pub payment_status: BackendPaymentStatus,
}

impl PaymentDetails {
    pub fn new(booking_id: BookingId) -> Self {
        Self {
            booking_id,
            payment_status: BackendPaymentStatus::Unpaid(None),
        }
    }

    pub fn mark_payment_complete(&mut self, transaction_ref: String) -> Result<(), String> {
        self.payment_status = BackendPaymentStatus::Paid(transaction_ref);
        Ok(())
    }

    pub fn mark_payment_not_complete(&mut self, reason: String) {
        self.payment_status = BackendPaymentStatus::Unpaid(Some(reason));
    }

    pub fn get_status_display(&self) -> String {
        match &self.payment_status {
            BackendPaymentStatus::Paid(ref_no) => format!("Payment confirmed (Ref: {})", ref_no),
            BackendPaymentStatus::Unpaid(None) => "Awaiting payment".to_string(),
            BackendPaymentStatus::Unpaid(Some(error)) => format!("Payment failed: {}", error),
        }
    }

    pub fn is_paid(&self) -> bool {
        matches!(self.payment_status, BackendPaymentStatus::Paid(_))
    }
}

#[derive(CandidType, Deserialize, Serialize, Clone, Debug)]
pub enum BackendPaymentStatus {
    /// transaction reference number from payments provider
    Paid(String),
    /// if the transaction failed, that would be here.
    /// if transaction is processing, then that is here too.
    Unpaid(Option<String>),
}

impl Default for BackendPaymentStatus {
    fn default() -> Self {
        Self::Unpaid(None)
    }
}
